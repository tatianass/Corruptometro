# Importar conjunto de dados "tre_sagres_unificado.csv"
# tre_sagres = read.csv("../../data/tre_sagres_unificado.csv",header=T, encoding = "UTF-8")
# Apresentar os possíveis níveis de Classe
table(tre_sagres$Classe)
# Partição de treino com x% dos dados
#train_idx = caret::createDataPartition(y=tre_sagres$Classe, p=.9, list=FALSE)
test_idx = which(tre_sagres$Candidato2016)
# Conjunto de treino e teste
test = tre_sagres[test_idx,]
train = tre_sagres[-test_idx,]
# features do conjunto de treino
#features.names = c("nu_Dispensas", "nu_Aditivo_Prazo", "nu_Aditivo_Devolucao", "nu_Aditivo_Valor", "nu_Aditivos_Totais", "nu_Contrato")
train.features = select(train, nu_Dispensas, nu_Aditivo_Prazo, nu_Aditivo_Devolucao, nu_Aditivo_Valor, nu_Aditivos_Totais, nu_Contrato)
test.features = select(test, nu_Dispensas, nu_Aditivo_Prazo, nu_Aditivo_Devolucao, nu_Aditivo_Valor, nu_Aditivos_Totais, nu_Contrato)
# Proporção dos conjuntos de treino e teste
prop.table(table(train$Classe))
prop.table(table(test$Classe))
fitControl = trainControl(method="repeatedcv", number=10, repeats=10, returnResamp="all")
labels = as.factor(train$Classe)
model = train(x=train.features, y=labels, trControl=fitControl, method="rf")
test_labels = as.factor(test$Classe)
predictions = predict(model,newdata=test.features)
prob = predict(model,newdata=test.features,type = "prob")
caret::confusionMatrix(predictions, test_labels)
# Excutar script data.R
source("imports.R")
source("data.R")
# Importar conjunto de dados "tre_sagres_unificado.csv"
# tre_sagres = read.csv("../../data/tre_sagres_unificado.csv",header=T, encoding = "UTF-8")
# Apresentar os possíveis níveis de Classe
table(tre_sagres$Classe)
# Partição de treino com x% dos dados
#train_idx = caret::createDataPartition(y=tre_sagres$Classe, p=.9, list=FALSE)
test_idx = which(tre_sagres$Candidato2016)
# Conjunto de treino e teste
test = tre_sagres[test_idx,]
train = tre_sagres[-test_idx,]
# features do conjunto de treino
#features.names = c("nu_Dispensas", "nu_Aditivo_Prazo", "nu_Aditivo_Devolucao", "nu_Aditivo_Valor", "nu_Aditivos_Totais", "nu_Contrato")
train.features = select(train, nu_Dispensas, nu_Aditivo_Prazo, nu_Aditivo_Devolucao, nu_Aditivo_Valor, nu_Aditivos_Totais, nu_Contrato)
test.features = select(test, nu_Dispensas, nu_Aditivo_Prazo, nu_Aditivo_Devolucao, nu_Aditivo_Valor, nu_Aditivos_Totais, nu_Contrato)
# Proporção dos conjuntos de treino e teste
prop.table(table(train$Classe))
prop.table(table(test$Classe))
#Treino do modelo
#grid = expand.grid(.ntree=c(10,20,30,40,50,100,200),.mtry=2,.model="tree")
fitControl = trainControl(method="repeatedcv", number=10, repeats=10, returnResamp="all")
labels = as.factor(train$Classe)
model = train(x=train.features, y=labels, trControl=fitControl, method="rf")
#
test_labels = as.factor(test$Classe)
predictions = predict(model,newdata=test.features)
prob = predict(model,newdata=test.features,type = "prob")
caret::confusionMatrix(predictions, test_labels)
fitControl = trainControl(method="repeatedcv", number=10, repeats=10, returnResamp="all")
labels = as.factor(train$Classe)
model = train(x=train.features, y=labels, trControl=fitControl, method="rf")
#
test_labels = as.factor(test$Classe)
predictions = predict(model,newdata=test.features)
prob = predict(model,newdata=test.features,type = "prob")
caret::confusionMatrix(predictions, test_labels)
fitControl = trainControl(method="repeatedcv", number=10, repeats=10, returnResamp="all")
labels = as.factor(train$Classe)
model = train(x=train.features, y=labels, trControl=fitControl, method="rf")
#
test_labels = as.factor(test$Classe)
predictions = predict(model,newdata=test.features)
prob = predict(model,newdata=test.features,type = "prob")
caret::confusionMatrix(predictions, test_labels)
# Excutar script data.R
source("imports.R")
source("data.R")
# Importar conjunto de dados "tre_sagres_unificado.csv"
# tre_sagres = read.csv("../../data/tre_sagres_unificado.csv",header=T, encoding = "UTF-8")
# Apresentar os possíveis níveis de Classe
table(tre_sagres$Classe)
# Partição de treino com x% dos dados
#train_idx = caret::createDataPartition(y=tre_sagres$Classe, p=.9, list=FALSE)
test_idx = which(tre_sagres$Candidato2016)
# Conjunto de treino e teste
test = tre_sagres[test_idx,]
train = tre_sagres[-test_idx,]
# features do conjunto de treino
#features.names = c("nu_Dispensas", "nu_Aditivo_Prazo", "nu_Aditivo_Devolucao", "nu_Aditivo_Valor", "nu_Aditivos_Totais", "nu_Contrato")
train.features = select(train, nu_Dispensas, nu_Aditivo_Prazo, nu_Aditivo_Devolucao, nu_Aditivo_Valor, nu_Aditivos_Totais, nu_Contrato)
test.features = select(test, nu_Dispensas, nu_Aditivo_Prazo, nu_Aditivo_Devolucao, nu_Aditivo_Valor, nu_Aditivos_Totais, nu_Contrato)
# Proporção dos conjuntos de treino e teste
prop.table(table(train$Classe))
prop.table(table(test$Classe))
#Treino do modelo
#grid = expand.grid(.ntree=c(10,20,30,40,50,100,200),.mtry=2,.model="tree")
fitControl = trainControl(method="repeatedcv", number=10, repeats=10, returnResamp="all")
labels = as.factor(train$Classe)
model = train(x=train.features, y=labels, trControl=fitControl, method="rf")
#
test_labels = as.factor(test$Classe)
predictions = predict(model,newdata=test.features)
prob = predict(model,newdata=test.features,type = "prob")
caret::confusionMatrix(predictions, test_labels)
fitControl = trainControl(method="repeatedcv", number=10, repeats=10, returnResamp="all")
labels = as.factor(train$Classe)
model = train(x=train.features, y=labels, trControl=fitControl, method="rf")
#
test_labels = as.factor(test$Classe)
predictions = predict(model,newdata=test.features)
prob = predict(model,newdata=test.features,type = "prob")
caret::confusionMatrix(predictions, test_labels)
fitControl = trainControl(method="repeatedcv", number=10, repeats=10, returnResamp="all")
labels = as.factor(train$Classe)
model = train(x=train.features, y=labels, trControl=fitControl, method="rf")
#
test_labels = as.factor(test$Classe)
predictions = predict(model,newdata=test.features)
prob = predict(model,newdata=test.features,type = "prob")
caret::confusionMatrix(predictions, test_labels)
fitControl = trainControl(method="repeatedcv", number=10, repeats=10, returnResamp="all")
labels = as.factor(train$Classe)
model = train(x=train.features, y=labels, trControl=fitControl, method="rf")
#
test_labels = as.factor(test$Classe)
predictions = predict(model,newdata=test.features)
prob = predict(model,newdata=test.features,type = "prob")
caret::confusionMatrix(predictions, test_labels)
10/25
10/21
tre_sagres = read.csv("../../../TRE_Sagres_Resp_Eleito_Final.csv",header=T, encoding = "UTF-8")
table(tre_sagres$Classe)
tre_sagres_jul <- read.csv('../../data/TRE_Sagres_Resp_Eleito.csv', encoding = "UTF-8")
tre_sagres_n_jul <- read.csv('../../data/TRE_Sagres_Eleit_Idon.csv', encoding = "UTF-8")
tre_sagres <- read.csv("../../../TRE_Sagres_Resp_Eleito_Final.csv",header=T, encoding = "UTF-8")
# Fun??o para modificar o ano.
# Gest?es entre 2009 e 2012 tem o ano modificado para 2009
# Gest?es entre 2013 e 2016 tem o ano modificado para 2013
source("imports.R")
relabel_ano <- function(x){
ifelse(x >= 2009 && x <2013, 2009, 2013)
}
# Carregar conjunto de dados
#tre_sagres_jul <- read.csv('../../data/TRE_Sagres_Resp_Eleito.csv', encoding = "UTF-8")
#tre_sagres_n_jul <- read.csv('../../data/TRE_Sagres_Eleit_Idon.csv', encoding = "UTF-8")
tre_sagres <- read.csv("../../../TRE_Sagres_Resp_Eleito_Final.csv",header=T, encoding = "UTF-8")
ugestora <- read.csv('../../data/codigo_ugestora.csv', encoding = "UTF-8")
contrato <- read.csv('../../data/contratos.csv', encoding = "UTF-8")
aditivos <- read.csv("../../data/aditivos.csv", encoding = "UTF-8")
quantidadeEleitores = read.csv("../../data/quantidadeEleitores.csv", encoding = "UTF-8")
candidadosEleicao2016 = read.csv("../../data/Candidatos_eleicao_2016.csv", encoding = "UTF-8")
candidadosEleicao2016$Candidato2016 <- TRUE
tre_sagres <- merge(tre_sagres, candidadosEleicao2016, by = c("de_Ugestora","ELEITO"), all.x = T)
tre_sagres <- merge(tre_sagres, candidadosEleicao2016, by = c("de_Ugestora","Eleito"), all.x = T)
tre_sagres <- merge(tre_sagres, candidadosEleicao2016, by.x = c("de_Ugestora","Eleito"), by.y = c("de_Ugestora","ELEITO"), all.x = T)
tre_sagres[is.na(tre_sagres)] <- FALSE
View(tre_sagres)
licitacoes <- subset(contrato, tp_Licitacao %in% c(6, 7) & dt_Ano > 2008)
licitacoes$dt_Ano <- with(licitacoes, unlist(lapply(dt_Ano, relabel_ano)))
nu_Dispensas <- aggregate(tp_Licitacao ~ cd_UGestora + dt_Ano, licitacoes, length)
colnames(nu_Dispensas)[3] <- "nu_Dispensas"
tre_sagres <- merge(tre_sagres, nu_Dispensas, all.x = T, by.x=c("cd_Ugestora","dt_Ano"), by.y = c("cd_UGestora","dt_Ano"))
tre_sagres$nu_Dispensas <- with(tre_sagres, ifelse(is.na(nu_Dispensas),0,nu_Dispensas))
aditivos$dt_Ano <- with(aditivos, unlist(lapply(dt_Ano, relabel_ano)))
aditivo_De_Prazo <- filter(aditivos, vl_Aditivo == "0,0000")
aditivo_De_Prazo <- group_by(aditivo_De_Prazo, cd_UGestora, dt_Ano) %>% mutate(nu_Aditivo_Prazo = length(nu_Aditivo))
aditivo_De_Prazo <- select(aditivo_De_Prazo, cd_UGestora, dt_Ano ,nu_Aditivo_Prazo)
aditivo_De_Devolucao = filter(aditivos, regexpr('-', vl_Aditivo) > 0)
aditivo_De_Devolucao <- group_by(aditivo_De_Devolucao, cd_UGestora, dt_Ano) %>% mutate(nu_Aditivo_Devolucao = length(nu_Aditivo))
aditivo_De_Devolucao <- select(aditivo_De_Devolucao, cd_UGestora, dt_Ano, nu_Aditivo_Devolucao)
aditivo_De_Valor = filter(aditivos, regexpr('-', vl_Aditivo) < 0)
aditivo_De_Valor <- group_by(aditivo_De_Valor, cd_UGestora, dt_Ano) %>% mutate(nu_Aditivo_Valor = length(nu_Aditivo))
aditivo_De_Valor <- select(aditivo_De_Valor, cd_UGestora, dt_Ano, nu_Aditivo_Valor)
nu_Aditivos_Totais <- merge(aditivo_De_Prazo, aditivo_De_Devolucao, by = c("cd_UGestora", "dt_Ano"), all.x = T)
nu_Aditivos_Totais <- merge(nu_Aditivos_Totais, aditivo_De_Valor, by = c("cd_UGestora", "dt_Ano"), all.x = T)
nu_Aditivos_Totais[is.na(nu_Aditivos_Totais)] <- 0
nu_Aditivos_Totais$nu_Aditivos_Totais <- with(nu_Aditivos_Totais, nu_Aditivo_Prazo + nu_Aditivo_Devolucao + nu_Aditivo_Valor)
nu_Aditivos_Totais <- unique(nu_Aditivos_Totais)
tre_sagres <- merge(tre_sagres, nu_Aditivos_Totais, by.x = c("cd_Ugestora","dt_Ano"), by.y = c("cd_UGestora","dt_Ano"), all.x = T)
tre_sagres[is.na(tre_sagres)] <- 0
View(tre_sagres)
conviteLicitacaoPorGestao <- filter(contrato, tp_Licitacao == 3)
conviteLicitacaoPorGestao$dt_Ano <- with(conviteLicitacaoPorGestao, unlist(lapply(dt_Ano, relabel_ano)))
conviteLicitacaoPorGestao <- aggregate(nu_Contrato ~ cd_UGestora + dt_Ano, conviteLicitacaoPorGestao, length)
tre_sagres <- merge(tre_sagres, conviteLicitacaoPorGestao, by.x = c("cd_Ugestora","dt_Ano"), by.y = c("cd_UGestora","dt_Ano"), all.x = T)
# Adiciona Quantidade de Eleitores por Municipio e Distancia da capital
quantidadeEleitores = select(quantidadeEleitores, Abrangencia, Quantidade2009, Quantidade2013, DistanciaParaCapital)
quantidadeEleitores <- group_by(quantidadeEleitores, Abrangencia) %>% mutate(Media = (Quantidade2009 + Quantidade2013)/2)
tre_sagres <- merge(tre_sagres, quantidadeEleitores, by.x = c("de_Ugestora"), by.y = c("Abrangencia"), all.x = T)
tre_sagres[is.na(tre_sagres)] <- 0
tre_sagres <- unique(tre_sagres)
View(tre_sagres)
table(tre_sagres$Classe)
# Partição de treino com x% dos dados
#train_idx = caret::createDataPartition(y=tre_sagres$Classe, p=.9, list=FALSE)
test_idx = which(tre_sagres$Candidato2016)
# Conjunto de treino e teste
test = tre_sagres[test_idx,]
train = tre_sagres[-test_idx,]
train.features = select(train, nu_Dispensas, nu_Aditivo_Prazo, nu_Aditivo_Devolucao, nu_Aditivo_Valor, nu_Aditivos_Totais, nu_Contrato)
test.features = select(test, nu_Dispensas, nu_Aditivo_Prazo, nu_Aditivo_Devolucao, nu_Aditivo_Valor, nu_Aditivos_Totais, nu_Contrato)
prop.table(table(train$Classe))
prop.table(table(train$classe))
prop.table(table(test$classe))
fitControl = trainControl(method="repeatedcv", number=10, repeats=10, returnResamp="all")
labels = as.factor(train$Classe)
model = train(x=train.features, y=labels, trControl=fitControl, method="rf")
table(tre_sagres$classe)
prop.table(table(train$classe))
prop.table(table(test$classe))
fitControl = trainControl(method="repeatedcv", number=10, repeats=10, returnResamp="all")
labels = as.factor(train$classe)
model = train(x=train.features, y=labels, trControl=fitControl, method="rf")
test_labels = as.factor(test$classe)
predictions = predict(model,newdata=test.features)
prob = predict(model,newdata=test.features,type = "prob")
caret::confusionMatrix(predictions, test_labels)
fitControl = trainControl(method="repeatedcv", number=10, repeats=10, returnResamp="all")
labels = as.factor(train$classe)
model = train(x=train.features, y=labels, trControl=fitControl, method="rf")
#
test_labels = as.factor(test$classe)
predictions = predict(model,newdata=test.features)
prob = predict(model,newdata=test.features,type = "prob")
caret::confusionMatrix(predictions, test_labels)
fitControl = trainControl(method="repeatedcv", number=10, repeats=10, returnResamp="all")
labels = as.factor(train$classe)
model = train(x=train.features, y=labels, trControl=fitControl, method="rf")
#
test_labels = as.factor(test$classe)
predictions = predict(model,newdata=test.features)
prob = predict(model,newdata=test.features,type = "prob")
caret::confusionMatrix(predictions, test_labels)
fitControl = trainControl(method="repeatedcv", number=10, repeats=10, returnResamp="all")
labels = as.factor(train$classe)
model = train(x=train.features, y=labels, trControl=fitControl, method="rf")
#
test_labels = as.factor(test$classe)
predictions = predict(model,newdata=test.features)
prob = predict(model,newdata=test.features,type = "prob")
caret::confusionMatrix(predictions, test_labels)
fitControl = trainControl(method="repeatedcv", number=10, repeats=10, returnResamp="all")
labels = as.factor(train$classe)
model = train(x=train.features, y=labels, trControl=fitControl, method="rf")
#
test_labels = as.factor(test$classe)
predictions = predict(model,newdata=test.features)
prob = predict(model,newdata=test.features,type = "prob")
caret::confusionMatrix(predictions, test_labels)
tre_sagres <- read.csv("../../TRE_Sagres_Resp_Eleito_Final.csv",header=T, encoding = "UTF-8")
tre_sagres <- read.csv("../../data/TRE_Sagres_Resp_Eleito_Final.csv",header=T, encoding = "UTF-8")
# Excutar script data.R
source("imports.R")
source("data.R")
# Apresentar os possíveis níveis de Classe
table(tre_sagres$classe)
# Partição de treino com x% dos dados
#train_idx = caret::createDataPartition(y=tre_sagres$Classe, p=.9, list=FALSE)
test_idx = which(tre_sagres$Candidato2016)
# Conjunto de treino e teste
test = tre_sagres[test_idx,]
train = tre_sagres[-test_idx,]
# features do conjunto de treino
#features.names = c("nu_Dispensas", "nu_Aditivo_Prazo", "nu_Aditivo_Devolucao", "nu_Aditivo_Valor", "nu_Aditivos_Totais", "nu_Contrato")
train.features = select(train, nu_Dispensas, nu_Aditivo_Prazo, nu_Aditivo_Devolucao, nu_Aditivo_Valor, nu_Aditivos_Totais, nu_Contrato)
test.features = select(test, nu_Dispensas, nu_Aditivo_Prazo, nu_Aditivo_Devolucao, nu_Aditivo_Valor, nu_Aditivos_Totais, nu_Contrato)
# Proporção dos conjuntos de treino e teste
prop.table(table(train$classe))
prop.table(table(test$classe))
#Treino do modelo
#grid = expand.grid(.ntree=c(10,20,30,40,50,100,200),.mtry=2,.model="tree")
fitControl = trainControl(method="repeatedcv", number=10, repeats=10, returnResamp="all")
labels = as.factor(train$classe)
model = train(x=train.features, y=labels, trControl=fitControl, method="rf")
#
test_labels = as.factor(test$classe)
predictions = predict(model,newdata=test.features)
prob = predict(model,newdata=test.features,type = "prob")
caret::confusionMatrix(predictions, test_labels)
if(!require(FSelector)){
install.packages("FSelector")
}
library(FSelector)
tre_sagres <- read.csv("../../data/TRE_Sagres_Resp_Eleito_Final.csv", encoding = "UTF-8")
source("imports.R")
tre_sagres <- read.csv("../../data/TRE_Sagres_Resp_Eleito_Final.csv", encoding = "UTF-8")
View(tre_sagres)
tre_sagres <- read.csv("../../data/tre_sagres_unificado.csv", encoding = "UTF-8")
View(tre_sagres)
features <- tre_sagres[,c(5,7:16)]
View(features)
information.gain(classe ~ ., features)
gain.ratio(classe ~ ., features)
wilcox.test(features$nu_Dispensas)
?wilcox.test
irregulares <- subset(features, classe == 'IRREGULAR')
nao_irregulares <- subset(features, classe == 'NAO IRREGULAR')
wilcox.test(irregulares$nu_Dispensas, nao_irregulares$nu_Dispensas)
wilcox.test(irregulares$nu_Aditivo_Prazo, nao_irregulares$nu_Aditivo_Prazo)
wilcox.test(irregulares$nu_Dispensas, nao_irregulares$nu_Dispensas)
wilcox.test(irregulares$nu_Aditivo_Devolucao, nao_irregulares$nu_Aditivo_Devolucao)
wilcox.test(irregulares$nu_Aditivo_Valor, nao_irregulares$nu_Aditivo_Valor)
wilcox.test(irregulares$DistanciaParaCapital, nao_irregulares$DistanciaParaCapital)
wilcox.test(irregulares$nu_Dispensas, nao_irregulares$nu_Dispensas)
wilcox.test(irregulares$nu_Dispensas, nao_irregulares$nu_Dispensas)
wilcox.test(irregulares$nu_Aditivo_Prazo, nao_irregulares$nu_Aditivo_Prazo)
wilcox.test(irregulares$nu_Aditivo_Devolucao, nao_irregulares$nu_Aditivo_Devolucao)
wilcox.test(irregulares$nu_Aditivo_Valor, nao_irregulares$nu_Aditivo_Valor)
wilcox.test(irregulares$nu_Aditivos_Totais, nao_irregulares$nu_Aditivos_Totais)
wilcox.test(irregulares$nu_Contrato, nao_irregulares$nu_Contrato)
wilcox.test(irregulares$nu_Dispensas, nao_irregulares$nu_Dispensas, paired = F)
wilcox.test(irregulares$nu_Aditivo_Prazo, nao_irregulares$nu_Aditivo_Prazo, paired = F)
wilcox.test(irregulares$nu_Aditivo_Devolucao, nao_irregulares$nu_Aditivo_Devolucao, paired = F)
wilcox.test(irregulares$nu_Aditivo_Valor, nao_irregulares$nu_Aditivo_Valor, paired = F)
wilcox.test(irregulares$nu_Aditivos_Totais, nao_irregulares$nu_Aditivos_Totais, paired = F)
View(tre_sagres)
features <- tre_sagres[,c(5,7:12)]
View(features)
features <- tre_sagres[,c(5,7:13)]
View(features)
features <- tre_sagres[,c(5,7:12)]
information.gain(classe ~ ., features)
gain.ratio(classe ~ ., features)
wilcox.test(irregulares$nu_Aditivo_Valor, nao_irregulares$nu_Aditivo_Valor, paired = F)
wilcox.test(irregulares$nu_Aditivos_Totais, nao_irregulares$nu_Aditivos_Totais, paired = F)
wilcox.test(irregulares$nu_Contrato, nao_irregulares$nu_Contrato, paired = F)
wilcox.test(irregulares$nu_Dispensas, nao_irregulares$nu_Dispensas, paired = F)
wilcox.test(irregulares$nu_Aditivo_Prazo, nao_irregulares$nu_Aditivo_Prazo, paired = F)
wilcox.test(irregulares$nu_Aditivo_Devolucao, nao_irregulares$nu_Aditivo_Devolucao, paired = F)
wilcox.test(irregulares$nu_Aditivo_Valor, nao_irregulares$nu_Aditivo_Valor, paired = F)
wilcox.test(irregulares$nu_Aditivos_Totais, nao_irregulares$nu_Aditivos_Totais, paired = F)
wilcox.test(irregulares$nu_Contrato, nao_irregulares$nu_Contrato, paired = F)
irregulares$nu_Contrato
nao_irregulares$nu_Contrato
summary(irregulares$nu_Contrato)
summary(nao_irregulares$nu_Contrato)
wilcox.test(irregulares$nu_Contrato, nao_irregulares$nu_Contrato, paired = F)
information.gain(classe ~ ., features)
source("imports.R")
tre_sagres <- read.csv("../../data/tre_sagres_unificado.csv", encoding = "UTF-8")
features <- tre_sagres[,c(5,7:12)]
information.gain(classe ~ ., features)
gain.ratio(classe ~ ., features)
wilcox.test(irregulares$nu_Dispensas, nao_irregulares$nu_Dispensas, paired = F)
tre_sagres <- read.csv("../../data/tre_sagres_unificado.csv", encoding = "UTF-8")
features <- tre_sagres[,c(5,7:12)]
information.gain(classe ~ ., features)
gain.ratio(classe ~ ., features)
irregulares <- subset(features, classe == 'IRREGULAR')
nao_irregulares <- subset(features, classe == 'NAO IRREGULAR')
wilcox.test(irregulares$nu_Dispensas, nao_irregulares$nu_Dispensas, paired = F)
wilcox.test(irregulares$nu_Aditivo_Prazo, nao_irregulares$nu_Aditivo_Prazo, paired = F)
wilcox.test(irregulares$nu_Aditivo_Devolucao, nao_irregulares$nu_Aditivo_Devolucao, paired = F)
wilcox.test(irregulares$nu_Aditivo_Valor, nao_irregulares$nu_Aditivo_Valor, paired = F)
wilcox.test(irregulares$nu_Aditivos_Totais, nao_irregulares$nu_Aditivos_Totais, paired = F)
wilcox.test(irregulares$nu_Contrato, nao_irregulares$nu_Contrato, paired = F)
# Excutar script data.R
source("imports.R")
source("data.R")
# Apresentar os possíveis níveis de Classe
table(tre_sagres$classe)
# Partição de teste com os candidatos reeleitos
test_idx = which(tre_sagres$Candidato2016)
# Conjunto de treino e teste
test = tre_sagres[test_idx,]
train = tre_sagres[-test_idx,]
# features do conjunto de treino
#features.names = c("nu_Dispensas", "nu_Aditivo_Prazo", "nu_Aditivo_Devolucao", "nu_Aditivo_Valor", "nu_Aditivos_Totais", "nu_Convites")
train.features = select(train, nu_Aditivo_Valor, nu_Aditivos_Totais)
test.features = select(test, nu_Aditivo_Valor, nu_Aditivos_Totais)
# Proporção dos conjuntos de treino e teste
prop.table(table(train$classe))
prop.table(table(test$classe))
#Treino do modelo
#grid = expand.grid(.ntree=c(10,20,30,40,50,100,200),.mtry=2,.model="tree")
fitControl = trainControl(method="repeatedcv", number=10, repeats=10, returnResamp="all")
labels = as.factor(train$classe)
model = train(x=train.features, y=labels, trControl=fitControl, method="rf")
test_labels = as.factor(test$classe)
predictions = predict(model,newdata=test.features)
prob = predict(model,newdata=test.features,type = "prob")
caret::confusionMatrix(predictions, test_labels)
View(tre_sagres)
View(test)
View(test)
View(test.features)
?model
?train
View(train)
model = train(data = train, form = classe ~ nu_Aditivo_Valor + nu_Aditivos_Totais, trControl=fitControl, method="rf")
model = train(form = classe ~ nu_Aditivo_Valor + nu_Aditivos_Totais, data = train, trControl=fitControl, method="rf")
predictions = predict(model,newdata=test)
predictions
prob = predict(model,newdata=test,type = "prob")
prob
# Excutar script data.R
source("imports.R")
source("data.R")
# Apresentar os possíveis níveis de Classe
table(tre_sagres$classe)
# Partição de teste com os candidatos reeleitos
test_idx = which(tre_sagres$Candidato2016)
# Conjunto de treino e teste
test = tre_sagres[test_idx,]
train = tre_sagres[-test_idx,]
# Proporção dos conjuntos de treino e teste
prop.table(table(train$classe))
prop.table(table(test$classe))
#Treino do modelo
fitControl = trainControl(method="repeatedcv", number=10, repeats=10, returnResamp="all")
labels = as.factor(train$classe)
model = train(form = classe ~ nu_Aditivo_Valor + nu_Aditivos_Totais, data = train, trControl=fitControl, method="rf")
predictions = predict(model,newdata=test)
prob = predict(model,newdata=test,type = "prob")
caret::confusionMatrix(predictions, test_labels)
caret::confusionMatrix(predictions, test$classe)
a = cbind(test, prob)
View(a)
View(a)
?filter
vars <- c("Petal.Length", "Petal.Width")
select(iris, one_of(vars))
?one_of
select(a, de_Ugestora, Eleito, nu_Aditivo_Valor, nu_Aditivos_Totais, IRREGULAR)
select(a, de_Ugestora, Eleito, nu_Aditivo_Valor, nu_Aditivos_Totais, Probabilidade = IRREGULAR)
prob.table = cbind(test, prob) %>% select(prob.table, Nome = Eleito, Prefeitura = de_Ugestora, NAV = nu_Aditivo_Valor, NAT = nu_Aditivos_Totais, Probabilidade = IRREGULAR)
prob.table = cbind(test, prob) %>% select(Nome = Eleito, Prefeitura = de_Ugestora, NAV = nu_Aditivo_Valor, NAT = nu_Aditivos_Totais, Probabilidade = IRREGULAR)
View(prob.table)
prob.table = cbind(test, prob) %>%
select(Nome = Eleito, Prefeitura = de_Ugestora, NAV = nu_Aditivo_Valor, NAT = nu_Aditivos_Totais, Probabilidade = IRREGULAR)
install.packages("rjson")
if(!require(rjson)){
install.packages("rjson")
}
library(rjson)
tbl <- table(round(runif(100, 1, 5)))
library(rjson)
tbl
sink("json.txt")
?sink
cat(toJSON(tbl))
sink()
file.show("json.txt")
tbl
file.show("json.txt")
sink("json1.txt")
cat(toJSON(tbl))
sink()
?toJSON
?CAT
?cat
tbl <- table(round(runif(100, 1, 5)))
sink("candidatos.json")
cat(toJSON(prob.table))
sink()
t(prob.table)
prob.table = t(prob.table)
View(prob.table)
sink("candidatos.json")
cat(toJSON(prob.table))
sink()
prob.table = cbind(test, prob) %>%
select(Nome = Eleito, Prefeitura = de_Ugestora, NAV = nu_Aditivo_Valor, NAT = nu_Aditivos_Totais, Probabilidade = IRREGULAR)
sink("candidatos.json")
cat(toJSON(prob.table))
sink()
plot(cars, pch=2)
json_cars <- toJSON(as.list(cars))
json_cars
install.packages("jsonlite")
library("jsonlite")
jsoncars <- toJSON(mtcars, pretty=TRUE)
cat(jsoncars)
mtcars
a <- toJSON(prob.table, pretty=TRUE)
cat(a)
a
x <- iris[1:3,]
x
toJSON(x)
stream_out(x)
cat(stream_out(prob.table))
sink("candidatos.json")
cat(toJSON(prob.table))
sink()
sink("candidatos.json")
cat(stream_out(prob.table))
sink()
sink("../../data/candidatos.json")
cat(toJSON(prob.table))
sink()
# Excutar script data.R
source("imports.R")
source("data.R")
# Apresentar os possíveis níveis de Classe
table(tre_sagres$classe)
# Partição de teste com os candidatos reeleitos
test_idx = which(tre_sagres$Candidato2016)
# Conjunto de treino e teste
test = tre_sagres[test_idx,]
train = tre_sagres[-test_idx,]
# Proporção dos conjuntos de treino e teste
prop.table(table(train$classe))
prop.table(table(test$classe))
#Treino do modelo
fitControl = trainControl(method="repeatedcv", number=10, repeats=10, returnResamp="all")
labels = as.factor(train$classe)
model = train(form = classe ~ nu_Aditivo_Valor + nu_Aditivos_Totais, data = train, trControl=fitControl, method="rf")
predictions = predict(model,newdata=test)
prob = predict(model,newdata=test,type = "prob")
caret::confusionMatrix(predictions, test$classe)
prob.table = cbind(test, prob) %>%
select(Nome = Eleito, Prefeitura = de_Ugestora, NAV = nu_Aditivo_Valor, NAT = nu_Aditivos_Totais, Probabilidade = IRREGULAR)
sink("../../data/candidatos.json")
cat(toJSON(prob.table))
sink()
